
# CHAT1 입문자를 위한 지식
## 1.1 리액트는 왜 필요한가요?
- 업데이트때문에 필요
- 업데이트 대규모 수행 어려움 - 성능 / 신뢰성 / 보안
## 1.2 리액트 이전의 세계
- 인터페이스 상태 예시 - 클릭 전 / 클릭했지만 대기중 / 클릭 후 성공 / 클릭 후 실패
- 업데이트 단계
  1) 엘리먼트 탐색
  2) 버튼에 이벤트 리스터 추가
  3) 이벤트에 상태 업데이트
  4) 페이지 벗어날때 리스너 제거 및 상태 정리
- 디바운싱 : 이벤트가 마지막으로 발생한 후 설정된 시간이 경과하기 전까지 함수 실행을 지연
- 스로틀링 : 함수가 설정된 시간 간격 내에 한번만 실행되도록 제한해 빈번하게 실행되지 않게 함
### 1.2.1 JQuery
### 1.2.2 Backbone
### 1.2.3 Knockout
### 1.2.4 앵귤러JS
## 1.3 리액트의 등장
### 1.3.1 리액트의 핵심가치
- 선언적 코드와 명령형코드
- 가상 DOM
- 컴포넌트 모델
- 불변 상태
### 1.3.2 리액트의 출시
## 1.4 그래서... 리액트는 왜 필요한가요?
## 1.5 돌아보기
## 1.6 복습하기
## 1.7 미리보기

# CHAT2 JSK
## 2.1 자바스크립트 XML?
## 2.2 JSX의 장점
## 2.3 JSX의 약점
## 2.4 내부 동작
### 2.4.1 코드는 어떻게 동작하나요?
### 2.4.2 JSX로 자바스크릷트 구문 확장하기
## 2.5 JSX 프라그마
## 2.6 표현식
## 2.7 돌아보기
## 2.8 복습하기
## 2.9 미리보기

# CHAP3 가상 DOM

---

## 3.1 가상 DOM 소개

**왜:** 웹 애플리케이션이 복잡해질수록 실제 DOM을 직접 관리하기 어렵고 성능 문제가 발생하기 때문

**내용:**
- 가상 DOM은 UI의 "가상" 표현을 메모리에 유지하고 실제 DOM과 동기화하는 개념
- 이 동기화 과정을 재조정(Reconciliation)이라 함
- 리플로우: 요소의 위치/크기 변경 시 레이아웃 재계산 (비용 높음)
- 리페인트: 시각적 스타일만 다시 그림 (비용 상대적으로 낮음)
- 가상 DOM은 변경사항을 모아 한 번에 처리하여 리플로우/리페인트를 최소화

---

## 3.2 실제 DOM

**왜:** 가상 DOM을 이해하려면 먼저 실제 DOM이 무엇이고 어떻게 작동하는지 알아야 하기 때문

**내용:**
- 브라우저가 HTML을 파싱하여 만드는 트리 구조
- 각 HTML 요소가 노드로 표현됨
- JavaScript를 통해 동적으로 조작 가능

---

### 3.2.1 실제 DOM의 문제점

**왜:** 실제 DOM의 한계를 알아야 가상 DOM이 왜 필요한지 이해할 수 있기 때문

**내용:**
| 문제점 | 설명 |
|--------|------|
| 느린 조작 속도 | DOM API 호출 자체가 비용이 높음 |
| 전체 재렌더링 | 하나의 요소 변경 시 하위 트리 전체가 다시 렌더링될 수 있음 |
| 연쇄적 리플로우 | 부모/자식 요소까지 레이아웃 재계산 발생 |
| 잦은 리페인트 | 스타일 변경마다 화면을 다시 그림 |
| 비효율적 업데이트 | 변경되지 않은 부분도 함께 처리됨 |

---

### 3.2.2 문서 조각

**왜:** 실제 DOM의 문제를 브라우저 자체적으로 해결하려는 시도가 있었고, 이것이 가상 DOM의 기초가 되기 때문

**내용:**
- DOM 노드를 담는 경량 컨테이너
- 여러 변경을 모아서 한 번에 DOM에 추가 가능
- 단일 리플로우/리페인트만 발생
- 가상 DOM 개념의 영감이 됨

---

## 3.3 가상 DOM 작동 방식

**왜:** 가상 DOM이 어떻게 실제 DOM의 문제를 해결하는지 이해해야 리액트를 효과적으로 사용할 수 있기 때문

**내용:**
1. 상태 변경 시 가상 DOM에 먼저 반영
2. 이전 가상 DOM과 비교 (Diffing)
3. 변경된 부분만 실제 DOM에 업데이트

---

### 3.3.1 리액트 엘리먼트

**왜:** 가상 DOM의 구성 단위를 알아야 내부 작동 원리를 이해할 수 있기 때문

**내용:**
- 가상 DOM에서 실제 DOM 요소를 나타내는 일반 JavaScript 객체
- `type`, `props`, `children` 등의 속성을 가짐
- 실제 DOM보다 생성/비교가 훨씬 빠름

---

### 3.3.2 가상 DOM과 실제 DOM 비교

**왜:** 두 DOM의 차이를 명확히 이해해야 왜 가상 DOM이 더 효율적인지 알 수 있기 때문

**내용:**
| 구분 | 실제 DOM | 가상 DOM |
|------|----------|----------|
| 업데이트 | 느림 | 빠름 |
| 조작 방식 | 직접 조작 | diffing 후 최소 업데이트 |
| 메모리 | 브라우저 메모리 | JS 메모리 (경량) |

---

### 3.3.3 효율적인 업데이트

**왜:** 가상 DOM의 핵심 가치인 성능 최적화가 어떻게 이루어지는지 알아야 하기 때문

**내용:**
1. 전체 가상 DOM 업데이트
2. 이전 버전과 비교 (Diffing)
3. 변경된 객체만 식별
4. 해당 부분만 실제 DOM에 반영
5. 화면 변경

→ 여러 업데이트를 배칭(batching)하여 단일 DOM 업데이트로 결합

---

## 3.4 돌아보기

**왜:** 3장에서 배운 핵심 개념을 정리하고 기억하기 위해

**내용:**
- 가상 DOM = 실제 DOM의 경량 메모리 표현
- Diffing 알고리즘으로 변경사항 효율적 감지
- 필요한 부분만 업데이트하여 성능 최적화
- 선언적 프로그래밍 방식 가능

---

## 3.5 복습하기

**왜:** 학습 내용을 스스로 점검하기 위해

**내용:**
- 가상 DOM이란 무엇인가?
- 실제 DOM의 문제점은?
- Diffing 알고리즘의 역할은?
- 리액트 엘리먼트란?

---

## 3.6 미리보기

**왜:** 다음 장과의 연결고리를 제공하여 학습 흐름을 이어가기 위해

**내용:**
- 4장에서는 재조정(Reconciliation)을 다룸
- 배칭, 스택 재조정자, 파이버 재조정자, 더블 버퍼링 등

---

# CHAP4 재조정

## 🎯 전체 흐름 (한 문장 요약)

> "가상 DOM(청사진)을 실제 DOM(현실)으로 만드는 과정이 **재조정**이고, 이를 효율적으로 하기 위해 **파이버**가 등장했다"
---

## 4.1 재조정 이해하기
```
📌 
- **키워드:** 청사진 → 현실
- "가상 DOM은 설계도일 뿐, 실제로 집을 짓는 건 재조정이 한다"
```
**왜:** 가상 DOM은 UI의 청사진일 뿐이며, 이를 실제 화면에 반영하는 과정(재조정)을 이해해야 리액트의 렌더링 원리를 파악할 수 있기 때문

**내용:**

**재조정(Reconciliation)이란?**
- 가상 DOM(청사진)을 실제 DOM(현실)으로 만드는 과정
- 이전 가상 DOM과 새로운 가상 DOM을 비교하여 최소한의 변경만 실제 DOM에 적용

**소스 흐름
- JSX -> React.createElement -> 엘리먼트 트리(가상 DOM)

**리액트의 렌더링 흐름:**
1. `ReactDOM.createRoot(element).render()` 호출
2. 컴포넌트 실행 → 가상 DOM(리액트 엘리먼트 트리) 생성
3. 이전 가상 DOM과 비교 (Diffing)
4. 변경된 부분만 실제 DOM에 반영 (Commit)

**핵심 개념:**
| 용어 | 설명 |
|------|------|
| 가상 DOM | UI 상태의 청사진 (메모리상의 객체) |
| 재조정 | 청사진을 현실(실제 DOM)로 만드는 과정 |
| Diffing | 이전/현재 가상 DOM 비교 |
| Commit | 변경사항을 실제 DOM에 적용 |

---

## 4.2 일괄 처리 (Batching)
```
📌 
- **키워드:** 모아서 한 번에
- "택배 10개를 하나씩 배달 vs 한 번에 배달 → 당연히 한 번에가 효율적"
```

**왜:** DOM 조작은 비용이 높기 때문에, 여러 변경사항을 개별적으로 처리하면 리플로우/리페인트가 반복되어 성능이 저하됨. 이를 방지하기 위해 변경사항을 모아서 한 번에 처리해야 하기 때문

**내용:**

**일괄 처리(Batching)란?**
- 여러 상태 변경을 모아서 한 번의 DOM 업데이트로 처리하는 방식
- 재조정은 "예상되는 다음 DOM 상태"와 "현재 DOM"을 일치시키는 과정

**문서 조각(Document Fragment)과의 연관성:**
| 구분 | 문서 조각 | 리액트 배칭 |
|------|-----------|-------------|
| 방식 | 여러 노드를 모아 한 번에 DOM에 추가 | 여러 상태 변경을 모아 한 번에 반영 |
| 결과 | 단일 리플로우/리페인트 | 단일 DOM 업데이트 |
| 주체 | 브라우저 API | 리액트 재조정자 |

**배칭의 효과:**
- 불필요한 중간 렌더링 방지
- 리플로우/리페인트 최소화
- 전체 애플리케이션 성능 향상

## 4.3 기존 기술
```
📌 
- **키워드:** 중단 불가, 버벅임
- "한 번 시작하면 끝까지 가야 함 → 큰 작업이면 화면이 멈춤"
```


**왜:** 현재의 파이버 재조정자를 이해하려면, 이전 방식(스택 재조정자)의 한계를 먼저 알아야 하기 때문

**내용:**
- 리액트 초기에는 스택(Stack) 데이터 구조 기반의 재조정자를 사용
- 스택: 후입선출(LIFO) 방식으로 작동하는 자료구조
- 과거 스택재종자는 우선순위 없고 가상 트리에 업데이트 순서대로

---

### 4.3.1 스택 재조정자


**왜:** 스택 재조정자의 문제점을 알아야 왜 파이버 재조정자가 필요했는지 이해할 수 있기 때문

**내용:**

**스택 재조정자의 작동 방식:**
- 컴포넌트 트리를 재귀적으로 순회하며 동기적으로 처리
- 한 번 시작하면 전체 트리를 끝까지 처리해야 함 (중단 불가)

**스택 재조정자의 문제점:**
| 문제점 | 설명 |
|--------|------|
| 동기적 처리 | 작업 중단/재개 불가능 |
| UI 블로킹 | 큰 트리 처리 시 메인 스레드 차단 |
| 우선순위 없음 | 모든 업데이트를 동일하게 처리 |
| 버벅임(Jank) | 애니메이션, 사용자 입력 지연 발생 |

**해결책:**
- 이 문제들을 해결하기 위해 **파이버(Fiber) 재조정자** 개발


---

## 4.4 파이버 재조정자
```
📌 
- **키워드:** 중단/재개 가능, 우선순위
- "5ms마다 쉬면서 급한 것(사용자 입력) 먼저 처리"
```

**왜:** 스택 재조정자의 한계(동기적 처리, UI 블로킹)를 극복하고 더 유연하고 효율적인 렌더링을 위해

**내용:**

**파이버(Fiber)란?**
- 재조정자를 위한 작업 단위
- 마크 에릭슨의 정의: "특정 시점에 존재하는 실제 컴포넌트 트리를 나타내는 리액트의 내부 데이터 구조"

**파이버 vs 리액트 엘리먼트:**
| 구분 | 파이버 | 리액트 엘리먼트 |
|------|--------|-----------------|
| 상태 | 상태 저장 가능 | 상태 없음 |
| 수명 | 오래 유지됨 | 임시적 |
| 용도 | 재조정 작업 단위 | UI 표현 |

---

### 4.4.1 데이터 구조로서의 파이버

**왜:** 파이버의 내부 구조를 알아야 재조정 과정에서 어떻게 우선순위를 정하고 동시 실행이 가능한지 이해할 수 있기 때문

**내용:**

**파이버의 특징:**
- 업데이트의 우선순위 지정 가능
- 동시 실행(Concurrent) 가능
- 변경 가능한(mutable) 인스턴스로 설계

**파이버 노드의 주요 속성:**
| 속성 | 설명 |
|------|------|
| tag | 파이버의 종류 |
| type | 컴포넌트 타입 |
| props | 전달된 속성 |
| stateNode | 실제 DOM 노드 참조 |

**작업 루프:**
- `beginWork`: 파이버 작업 시작, 하위 트리 탐색
- `completeWork`: 파이버 작업 완료, DOM 노드 생성/업데이트

---

### 4.4.2 더블 버퍼링
```
📌 
- **키워드:** current / workInProgress
- "게임에서 다음 장면을 미리 준비해두는 것과 같음"
```

**왜:** 화면 깜빡임 없이 부드러운 UI 업데이트를 위해 그래픽 처리 기법인 더블 버퍼링 개념을 적용했기 때문

**내용:**

**더블 버퍼링이란?**
- 두 개의 버퍼를 생성하여 깜빡임을 줄이고 체감 성능을 개선하는 기술
- 하나는 화면에 표시, 다른 하나는 백그라운드에서 준비

**리액트에서의 적용:**
| 트리 | 역할 |
|------|------|
| current | 현재 화면에 표시된 트리 |
| workInProgress | 백그라운드에서 준비 중인 트리 |

- 렌더링 완료 후 workInProgress가 current가 됨

---

### 4.4.3 파이버 재조정
```
📌 
- **키워드:** 계산(중단 가능) → 반영(중단 불가)
- "계획은 바꿀 수 있지만, 실행 중엔 못 바꿈"
```

**왜:** 파이버 재조정의 세부 단계를 이해해야 리액트가 어떻게 효율적으로 UI를 업데이트하는지 파악할 수 있기 때문

**내용:**

**두 가지 주요 단계:**

| 단계 | 설명 | 특징 |
|------|------|------|
| 렌더링 단계 | 변경사항 계산 | 중단/재개 가능 |
| 커밋 단계 | 실제 DOM 반영 | 동기적, 중단 불가 |

**렌더링 단계:**
- 리액트 스케줄러가 5밀리초마다 메인 스레드로 제어권 반환 (중단 가능)
- `beginWork`: current, workInProgress, renderLanes 처리
- `completeWork`: 작업 완료 및 DOM 준비

**커밋 단계:**
1. **변형 단계**: 실제 DOM 변경
2. **레이아웃 단계**: 레이아웃 계산

**효과(Effects) 종류:**
| 효과 | 설명 |
|------|------|
| 배치 효과 | 새 노드 추가 |
| 업데이트 효과 | 기존 노드 수정 |
| 삭제 효과 | 노드 제거 |
| 레이아웃 효과 | useLayoutEffect 실행 |

→ 모든 효과 처리 후 화면에 최종 표시
## 4.5 돌아보기
## 4.6 복습하기
## 4.6 미리보기

| 전환 | 멘트 예시 |
|------|-----------|
| 4.1 → 4.2 | "그럼 재조정을 어떻게 효율적으로 할까요? → 일괄 처리" |
| 4.2 → 4.3 | "예전에는 이걸 어떻게 했을까요? → 스택 재조정자" |
| 4.3 → 4.4 | "근데 문제가 있었어요 → 그래서 파이버가 나옴" |

---

## ⚡ 청중에게 남길 핵심 메시지

1. **재조정 = 가상 DOM을 실제로 적용하는 과정**
2. **스택(과거) → 파이버(현재)로 진화한 이유: 중단/재개 + 우선순위**
3. **렌더링(계산)은 중단 가능, 커밋(반영)은 중단 불가**


